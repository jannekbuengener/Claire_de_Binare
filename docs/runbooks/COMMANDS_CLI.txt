# Cleanroom Execution – CLI Command Pack
# Beweise: jeder Befehl sollte mit Exitcode 0 enden, Logs sichern.

## Dry-Run Track
git checkout -b feature/cleanroom-dryrun
cp <PLAN_DIR>/CLEANUP_PLAN.md docs/CLEANUP_PLAN.md
cp <PLAN_DIR>/MIGRATION_MAP.md docs/MIGRATION_MAP.md
cp <PLAN_DIR>/SECURITY_SANITATION_PLAN.md docs/SECURITY_SANITATION_PLAN.md
cp <PLAN_DIR>/PR_CLEANROOM_DRYRUN.md docs/PR_CLEANROOM_DRYRUN.md
cat <<'EOF' >> .gitignore
# Cleanroom ignore – artifacts & caches
artifacts/
backoffice/artifacts/
evidence/
__pycache__/
.coverage
*.coverage*
*.log
tmp_*
backups/
operations/logs/
*.sqlite*

# Secrets
.env
.env.*
*.pem
*.key
*.pfx
id_*
*.secrets
EOF
git add docs/CLEANUP_PLAN.md docs/MIGRATION_MAP.md docs/SECURITY_SANITATION_PLAN.md docs/PR_CLEANROOM_DRYRUN.md .gitignore
git commit -m "chore(cleanroom): add plans + gitignore (dry run)"
git push -u origin feature/cleanroom-dryrun
gh pr create --title "chore(cleanroom): prepare structure & policy dry run"   --body-file docs/PR_CLEANROOM_DRYRUN.md --label cleanup --label documentation --label security-prep   --milestone "Cleanroom Phase II Dry-Run"

## Security-Sanitation Track
git clone --mirror <REMOTE> repo-cleanroom-backup.git
git clone <REMOTE> sanitized-repo
cd sanitized-repo
git filter-repo --path .env --path postgres_env.txt --path postgres_env_runtime.txt   --path-glob ".env.*" --path-glob "*.pem" --path-glob "*.key" --path-glob "*.pfx"   --path-glob "id_*" --path-glob "*.secrets" --path-glob "*.sqlite*" --invert-paths
gitleaks detect --no-git --source .
pytest -q
docker compose -f compose.yml run --rm cdb_core pytest -q
# Enable push protection manually in GitHub UI
git push --force-with-lease origin <MAIN>

## Doku-Kuration Track
# (Nach Sanitation, pro geplanter Move)
mv archive/legacy_quickstart/QUICK_START.md docs/quickstart/QUICK_START.md
# ...
python tools/link_check.py  # Script aus Runbook
git add docs/**
git commit -m "docs(cleanroom): consolidate documentation tree"
git push -u origin feature/docs-cleanroom
